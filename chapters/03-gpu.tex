The core contribution of this work is a GPU-accelerated implementation of the
spectroscopy algorithm presented in~\cite{bisping2023process},
using the new WebGPU standard.
This chapter will give an overview on why WebGPU was chosen and how that
standard came to be among other GPU-compute frameworks.
Further we will discuss the GPU programming model,
how its massively parallelized architecture can be utilized
and which challenges it raises.

\section{WebGPU and the State of GPU-compute}

As their name suggests, Graphical Processing Units (GPUs) were initially built
to improve graphical processing capabilities of computer systems,
serving as \emph{graphics accelerators}.
At first they included mostly fixed-function hardware to run the usual
rendering pipeline.
This required the same calculations to be performed for every object to
be rendered and every pixel on the screen,
which was solved by running as much as possible in parallel in order to produce
fluent frame rates.
These graphics accelerators enabled real-time rendering performance far beyond
what is possible on a general-purpose CPU,
which is why their development was largely driven by the gaming industry.

But already early on people recognized the potential of using the parallel
GPU architecture not just for graphics rendering,
but for any kind of general-purpose computing that requires performing the same
instructions on a large amount of data.
GPUs gradually moved away from the fixed-function design and gained more
fine-grained programmability.
Along with that, specific programming environments were
developed to provide an easier interface for writing GPU compute programs.
Nvidia has long dominated the market by investing early in its
proprietary CUDA platform which supports Nvidia hardware only.
AMD has more recently been working on ROCm for their own GPUs.
OpenCL was meant to be a more portable alternative.

In another area WebGL was developed to bring GPU support into web browsers.
This was mainly intended for simpler graphics applications and is based on the
long-standing OpenGL graphics API\@.
Because of that, WebGL never really supported general-purpose compute programs.
Any efforts to improve this situation were abandoned%
\footnote{\url{https://registry.khronos.org/webgl/specs/latest/2.0-compute/}}
in favor of a new browser API\@: WebGPU\@.
Instead of OpenGL, WebGPU is based on more advanced graphics APIs
that expose modern GPU features:
Vulkan for Linux and Windows, DX12 for Windows and Metal for Apple.
General-purpose compute is one of the express features for WebGPU,
thus providing a GPU-programming API that is not only fully
platform-independent, but will even be able to run in any web browser.
However, as of the time of writing, the WebGPU specification is still in
development and full browser support is not yet available%
\footnote{\url{https://github.com/gpuweb/gpuweb/wiki/Implementation-Status}}.

For the GPU-code, this work uses \emph{wgpu}, an implementation of the WebGPU
standard written in the Rust programming language.
Applications using wgpu can both run natively, directly interfacing with the
operating system's graphics API,
or within a webpage through WebAssembly%
\footnote{WebAssembly is a sort of machine code format that many programming
languages, including Rust, can be compiled into
and then be executed by a web page.},
interfacing with the browser's WebGPU interface.
The Firefox browser even uses wgpu itself to implement WebGPU\@.


\section{Parallel Computing Model of a GPU}

\begin{figure}[ht]
\centering
\begin{tikzpicture}[scale=0.6,thick]
    \foreach \x/\num in {0/-1, 1.2/3, 2.4/2, 3.6/-7, 4.8/-4, 6/7, 7.2/0, 8.4/7}
    {
        \draw (\x, 0) node {\num} +(-.6, -.5) rectangle ++(.6, .5);
        \ifnum \num > 0
            \draw (\x, -1.5) +(-.6, -.5) rectangle ++(.6, .5);
            \draw[fill=blue!20] (\x, -3) +(-.6, -.5) rectangle ++(.6, .5);
        \else
            \draw[fill=blue!20] (\x, -1.5) +(-.6, -.5) rectangle ++(.6, .5);
            \draw (\x, -3) +(-.6, -.5) rectangle ++(.6, .5);
        \fi
        \draw (\x, -4.5) +(-.6, -.5) rectangle ++(.6, .5);
        \draw[->] (\x, -0.5) -- (\x, -1);
        \draw[->] (\x, -2) -- (\x, -2.5);
        \draw[->] (\x, -3.5) -- (\x, -4);
    }
    \node[anchor=east] at (-0.6, 0)   {\verb|a|};
    \node[anchor=west] at (-5, -0.75) {\verb|if a > 0|};
    \node[anchor=west] at (-5, -1.5)  {\verb|  c = a*a+b|};
    \node[anchor=west] at (-5, -2.25) {\verb|else|};
    \node[anchor=west] at (-5, -3)    {\verb|  c = a*a-b|};
\end{tikzpicture}
\caption{Branch divergence in parallel execution.
    Shaded boxes indicate idle threads. Adapted from~\cite{Hijma2023}.
}\label{fig:branching}
\end{figure}
