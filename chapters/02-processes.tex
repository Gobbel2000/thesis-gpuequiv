In order to talk about the algorithm to find equivalences between processes
and its GPU implementation,
we will first introduce the models that all this is based on.
First and foremost this includes an explanation and definition
of the models we use to represent processes.
Further we will explore different ways to compare two processes
and how that leads us to the equivalence spectrum
\cite{glabbeek1990spectrum}.
Finally we will outline how the algorithm works,
that gives us a multifaceted view of the relation of two processes
by testing multiple of those equivalences at once
\cite{bisping2023process}.

\section{Modeling Processes}

For our purposes we can think of a process as the set of actions it can perform.
After each of these actions the process enters a new state,
which is itself another process with another set of actions.
This forms a sort of state machine that at every step
moves to some other state by performing one of the currently available actions.
The series of actions being chosen
constitute the observable behavior of the machine,
while its current state defines what actions it can do next.

This state machine can then be seen as a directed graph
with a node for each state and an edge between two nodes,
if it can transition its state from one to the other.
Each edge is labeled with the action that is performed during the state
transition.
Such a graph is called a \emph{Labeled transition system} or \emph{LTS} for
short
\cite{reactive_systems}.

% Formal definition

\begin{definition}
    A labeled transition system is a triple
    $(\mathsf{Proc}, \mathsf{Act}, \rightarrow)$
    where:

    \begin{itemize}
        \item $\mathsf{Proc}$ is the set of states or processes,
        \item $\mathsf{Act}$ is a set of actions,
        \item $\rightarrow \subseteq \mathsf{Proc} \times \mathsf{Act} \times \mathsf{Proc}$
            is the transition relation.
            We also write
            $p \xrightarrow{\alpha} p'$ for $(p, \alpha, p') \in \rightarrow$,
            meaning we can transition from state $p$ to $p'$
            using the action $\alpha$.
    \end{itemize}
\end{definition}

% Maybe introduce an example here.

\section{Equivalences between Processes}

\section{Spectroscopy Algorithm}

\section{Energy Games} \label{sec:energy_games}

\begin{definition}[Energy updates \cite{bisping2023process}] \label{def:update}
    The set of $N$-dimensional energy updates $\mathbf{Up}_N$ contains
    $N$-tuples $(u_1, \ldots, u_N) \in \mathbf{Up}_N$ where each update $u_k, k
    \in [N]$ is
    either
    \begin{itemize}
        \item $u_k \in \{-1, 0\}$, or
        \item $u_k = \mathtt{min}_D$ where $D \subseteq [N]$ and $k \in D$.
    \end{itemize}

    The function
    $\mathsf{upd}_N: (\mathbf{En}_N, \mathbf{Up}_N) \rightarrow \mathbf{En}_N$
    applies an update to an energy tuple.
    The $k$-th component is given as:
    \begin{equation*}
        \mathsf{upd}_N(e, u)_k =
        \begin{cases}
            e_k + u_k,\quad &\text{if } u_k \in \{-1, 0\}, \\
            \min_{d \in D}{e_d},\quad &\text{if } u_k = \mathtt{min}_D.
        \end{cases}
    \end{equation*}
\end{definition}

\begin{definition}[Energy Games] \label{def:energy_game}
    We define an $N$-dimensional energy game as
    $(G, G_a, G_d, E, w, v_0)$, where 
    \begin{itemize}
        \item $G$ is a set of game positions.
        \item $G_a$ and $G_d$ are the sets of attacker and defender positions
            respectively.
            $G = G_a \cup G_d$ and $G_a \cap G_d = \emptyset$.
        \item $E \subseteq (G \times G)$ is the edge relation. $(G, E)$
            together form a directed game graph.
        \item $w: E \rightarrow \mathbf{Up}_N$ is a weight function, assigning an
            energy update to each edge.
        \item $v_0 \in G$ is the start position of the game.
    \end{itemize}
\end{definition}

\begin{definition}[Plays and costs]
    A \emph{play} $\rho$ on a given game is a sequence of positions:
    $\rho = g_0g_1 \ldots g_n$ where at each step
    $g_i \in G$ and $(g_i, g_{i+1}) \in E$.

    If a play cannot be further extended, that is, there exists no position
    $g_{n+1} \in G$ such that $(g_n, g_{n+1}) \in E$,
    that play is won by the player who is not stuck:
    if $g_n \in G_a$, the defender wins, if $g_n \in G_d$, the attacker wins.
    Infinite plays are won by the defender.

    \scriptsize{TODO: costs}
\end{definition}

