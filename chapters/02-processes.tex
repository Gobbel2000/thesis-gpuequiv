With the goal of introducing the algorithm for finding equivalences between
processes,
this chapter will introduce the theoretical concepts that this work is based on.
First and foremost this includes an explanation and definition
of the models we use to represent processes.
Further we will explore different ways to compare two processes and how that
leads us to the equivalence spectrum~\cite{glabbeek1990spectrum}.
Finally we will outline how the algorithm works,
that gives us a multifaceted view of the relation of two processes by testing
multiple of those equivalences at once~\cite{bisping2023process}.


\section{Modeling Processes}

We represent processes in a directed graph.
The outgoing edges of a node are the possible steps it can perform next.
Each edge is labelled with a specific action that occurs when taking that step.
After performing an action,
the process enters a new state represented by another node,
which is itself a process with its set of actions.
This forms a sort of state machine that at every step
moves to some other state by performing one of the currently available actions.
The series of actions being chosen
constitutes the observable behavior of the machine,
while its current state defines what actions it can do next.
Such a structure is called a \emph{Labeled transition system}
or \emph{LTS} for short~\cite{reactive_systems}.
Figure~\ref{fig:example_lts} gives an example for how the graph of an LTS might
look like.

\begin{definition}[Labeled transition system~\cite{reactive_systems}]
    A labeled transition system is a triple
    $(\mathsf{Proc}, \mathsf{Act}, {\rightarrow})$
    where:

    \begin{itemize}
        \item $\mathsf{Proc}$ is the set of states or processes,
        \item $\mathsf{Act}$ is a set of actions,
        \item ${\rightarrow} \subseteq \mathsf{Proc} \times \mathsf{Act} \times \mathsf{Proc}$
            is the transition relation.
            We also write
            $p \xrightarrow{\alpha} p'$ for $(p, \alpha, p') \in {\rightarrow}$,
            meaning we can transition from state $p$ to $p'$
            using the action $\alpha$.
    \end{itemize}
\end{definition}

\begin{figure}[htpb]
\begin{center}
\begin{tikzpicture}[p/.style={circle,draw},->]
    \node[p] (0) {$p_0$}
        child {node[p] {$p_1$}
            child {node[p] {$p_2$} edge from parent node[left] {$b$}}
            child {node[p] {$p_3$} edge from parent node[right] {$c$}}
            edge from parent node[left] {$a$}
        };
    \node[p] (4) [right=25mm of 0] {$p_4$}
        child {node[p] {$p_5$}
            child {node[p] {$p_7$} edge from parent node[left] {$b$}}
            edge from parent node[left] {$a$}
        }
        child {node[p] {$p_6$}
            child {node[p] {$p_8$} edge from parent node[right] {$c$}}
            edge from parent node[right] {$a$}
        };
\end{tikzpicture}
\end{center}
\caption{An example for an LTS. In this case,
    $\mathsf{Proc} = \{p_0, p_1, \ldots, p_8\}$ and
    $\mathsf{Act} = \{a, b, c\}$.
}%
\label{fig:example_lts}
\end{figure}


\section{Equivalences between Processes}

% Trace Equivalence
% Bisimilarity
% Equivalences characterized by energies (through HML)


\section{Energy Games}\label{sec:energy_games}

\begin{definition}[Energy updates~\cite{bisping2023process}]\label{def:update}
    The set of $N$-dimensional energy updates $\mathbf{Up}_N$ contains
    $N$-tuples $(u_1, \ldots, u_N) \in \mathbf{Up}_N$ where each update $u_k, k
    \in [N]$ is
    either
    \begin{itemize}
        \item $u_k \in \{-1, 0\}$, or
        \item $u_k = \mathtt{min}_D$ where $D \subseteq [N]$ and $k \in D$. % chktex 35
    \end{itemize}

    The function
    $\mathsf{upd}_N: (\mathbf{En}_N, \mathbf{Up}_N) \rightarrow \mathbf{En}_N$
    applies an update to an energy tuple.
    The $k$-th component is given as:
    \begin{equation*}
        \mathsf{upd}_N{(e, u)}_k =
        \begin{cases}
            e_k + u_k,\quad &\text{if } u_k \in \{-1, 0\}, \\
            \min_{d \in D}{e_d},\quad &\text{if } u_k = \mathtt{min}_D. % chktex 35
        \end{cases}
    \end{equation*}
\end{definition}

\begin{definition}[Energy Games]\label{def:energy_game}
    We define an $N$-dimensional energy game as
    $(G, G_a, G_d, E, w, v_0)$, where 
    \begin{itemize}
        \item $G$ is a set of game positions.
        \item $G_a$ and $G_d$ are the sets of attacker and defender positions
            respectively.
            $G = G_a \cup G_d$ and $G_a \cap G_d = \emptyset$.
        \item $E \subseteq (G \times G)$ is the edge relation. $(G, E)$
            together form a directed game graph.
        \item $w: E \rightarrow \mathbf{Up}_N$ is a weight function, assigning an
            energy update to each edge.
        \item $v_0 \in G$ is the start position of the game.
    \end{itemize}

    The function $\mathrm{Succ}: G \rightarrow 2^G$ gives the successors in the
    graph for a position.
    For each $g \in G$, $\mathrm{Succ}(g) = \{g' \in G \mid (g, g') \in E\}$.
    Similarly, $\mathrm{Pred}(g) = \{g' \in G \mid (g', g) \in E\}$ yields a
    position's predecessors.
\end{definition}

\begin{definition}[Plays and costs]
    A \emph{play} $\rho$ on a given game is a sequence of positions:
    $\rho = g_0g_1 \ldots g_n$ where at each step
    $g_i \in G$ and $(g_i, g_{i+1}) \in E$.

    If a play cannot be further extended, that is,
    $\mathrm{Succ}(g_n) = \emptyset$,
    that play is won by the player who is not stuck:
    if $g_n \in G_a$, the defender wins, if $g_n \in G_d$, the attacker wins.
    Infinite plays are won by the defender.

    \scriptsize{TODO: costs}
\end{definition}

%TODO: Inverse update function upd^{-1}
%TODO: Energy tuples, upwards-closed sets, representation by minimal energies

\section{Spectroscopy Algorithm}

