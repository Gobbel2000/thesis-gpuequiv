With the goal of introducing the algorithm for finding equivalences between
processes,
this chapter will introduce the theoretical concepts that this work is based on.
First and foremost this includes an explanation and definition
of the models we use to represent processes.
Further we will explore different ways to compare two processes and how that
leads us to the equivalence spectrum~\cite{glabbeek1990spectrum}.
Finally we will outline how the algorithm works,
that gives us a multifaceted view of the relation of two processes by testing
multiple of those equivalences at once~\cite{bisping2023process}.


\section{Modeling Processes}

We represent processes in a directed graph.
The outgoing edges of a node are the possible steps it can perform next.
Each edge is labelled with a specific action that occurs when taking that step.
After performing an action,
the process enters a new state represented by another node,
which is itself a process with its set of actions.
This forms a sort of state machine that at every step
moves to some other state by performing one of the currently available actions.
The series of actions being chosen
constitutes the observable behavior of the machine,
while its current state defines what actions it can do next.
Such a structure is called a \emph{Labeled transition system}
or \emph{LTS} for short~\cite{reactive_systems}.
Figure~\ref{fig:example_lts} gives an example for how the graph of an LTS might
look like.

\begin{definition}[Labeled transition system~\cite{reactive_systems}]
    A labeled transition system is a triple
    $(\mathsf{Proc}, \mathsf{Act}, {\rightarrow})$
    where:

    \begin{itemize}
        \item $\mathsf{Proc}$ is the set of states or processes,
        \item $\mathsf{Act}$ is a set of actions,
        \item ${\rightarrow} \subseteq \mathsf{Proc} \times \mathsf{Act} \times \mathsf{Proc}$
            is the transition relation.
            We also write
            $p \xrightarrow{\alpha} p'$ for $(p, \alpha, p') \in {\rightarrow}$,
            meaning we can transition from state $p$ to $p'$
            using the action $\alpha$.
    \end{itemize}
\end{definition}

\begin{figure}[tb]
\begin{center}
\begin{tikzpicture}[p/.style={circle,draw},->]
    \node[p] (0) {$p_0$}
        child {node[p] {$p_1$}
            child {node[p] {$p_2$} edge from parent node[left] {$b$}}
            child {node[p] {$p_3$} edge from parent node[right] {$c$}}
            edge from parent node[left] {$a$}
        };
    \node[p] (4) [right=25mm of 0] {$p_4$}
        child {node[p] {$p_5$}
            child {node[p] {$p_7$} edge from parent node[left] {$b$}}
            edge from parent node[left] {$a$}
        }
        child {node[p] {$p_6$}
            child {node[p] {$p_8$} edge from parent node[right] {$c$}}
            edge from parent node[right] {$a$}
        };
\end{tikzpicture}
\end{center}
\caption{An example for an LTS\@. In this case,
    $\mathsf{Proc} = \{p_0, p_1, \ldots, p_8\}$ and
    $\mathsf{Act} = \{a, b, c\}$.
}%
\label{fig:example_lts}
\end{figure}


\section{Equivalences between Processes}

One of the most important questions that arises in the context of transition
systems is whether two processes show the same behavior.
This is a difficult question,
because there are many different ways to define
what \enquote{equivalent behavior} means.
This section will present two important definitions: Trace equivalence and
Bisimilarity.

\subsubsection{Trace Equivalence}

A simple way to qualify the behavior of a process is to look at the possible
strings of actions (traces) it can perform.
This is particularly apparent when viewing an LTS as a sort of automaton.
A sequence of actions $\alpha_1, \ldots, \alpha_k \in \mathsf{Act}^*$
is a trace of a process $p$ if
$p \xrightarrow{\alpha_1} p_1 \xrightarrow{\alpha_2} p_2
\ldots p_{k-1} \xrightarrow{\alpha_k} p_k$.
The function $Traces(p)$ produces the set of all traces for a process $p$.
We now call two processes $p$ and $q$ \emph{trace-equivalent}
if $Traces(p) = Traces(q)$~\cite{reactive_systems}.

For example, in Figure~\ref{fig:example_lts} the traces of $p_0$ are
$Traces(p_0) = \{a, ab, ac\}$.
The process $p_4$ can produce exactly the same traces,
so $p_0$ and $p_4$ are trace-equivalent.
However it is not difficult to see some difference in the graphs of both
processes that this comparison seems to ignore.
Indeed, trace equivalence is one of the weakest equivalence notions,
meaning it more easily equates processes.
An even weaker equivalence would be \emph{enabledness},
which already equates two processes
if they have the same set of enabled actions,
given as
$\{\alpha \in \mathsf{Act} \mid
   \exists p' \in \mathsf{Proc}\,.\,p \xrightarrow{\alpha} p'\}$
for a process $p$.


\subsubsection{Bisimilarity}

\subsection{Hennessy--Milner Logic}

A very useful tool when discussing process equivalences is the
Hennessy--Milner logic (or HML),
which is a modal logic that can be used to formalize various
properties of a process.
A process satisfies a HML-formula if it observes
the property specified by the formula,
otherwise it does not satisfy it.
We adopt the syntax from~\cite{bisping2023process},
which is slightly different although functionally equivalent to the definition
in~\cite{reactive_systems}.
This is relevant because we will later require precise control over the
structure of HML-formulas.

\begin{definition}[%
    Hennessy--Milner logic~\cite{bisping2023process,reactive_systems}]%
    \label{def:hml}
    The set $\mathcal{M}$ of HML-formulas over a set of actions $\mathsf{Act}$
    is constructed by the following grammar:
    \begin{align*}
        \varphi ::=\ &\langle \alpha \rangle \varphi, \qquad \alpha \in \mathsf{Act} \\
                \mid \quad &\bigwedge \{\psi, \psi, \ldots\} \\
        \psi ::=\ &\neg \varphi \mid \varphi
    \end{align*}
    The semantics $\llbracket \varphi \rrbracket$ of a formula
    $\varphi$ in a given LTS
    $(\mathsf{Proc}, \mathsf{Act}, {\rightarrow})$ denotes the set of processes in
    $\mathsf{Proc}$ that satisfy $\varphi$.
    It is recursively defined as:
    \begin{align*}
        \llbracket \langle \alpha \rangle \varphi \rrbracket &:=
            \{p \in \mathsf{Proc} \mid
              \exists p' \in \llbracket \varphi \rrbracket\,.\,
              p \xrightarrow{\alpha} p'
            \} \\
        \llbracket \neg \varphi \rrbracket &:=
            \mathsf{Proc} \setminus \llbracket \varphi \rrbracket \\
        \llbracket \bigwedge_{i \in I} \psi_i \rrbracket &:=
            \bigcap_{i \in I} \llbracket \psi_i \rrbracket
    \end{align*}
    The recursion in the above definition can be terminated using the empty
    conjunction $\top := \bigwedge \emptyset$
    which itself always evaluates to true:
    $\llbracket \top \rrbracket = \mathsf{Proc}$.
\end{definition}

To give a few examples,
both $p_0$ and $p_4$ of Figure~\ref{fig:example_lts} satisfy the HML-formula
$\langle a \rangle \langle b \rangle \top$,
which requires an $a$-transition followed by a $b$-transition,
thus encoding the trace $ab$.
However the formula
$\varphi = \langle a \rangle \bigwedge \{
    \langle b \rangle \top, \langle c \rangle \top \}$
is only satisfied by $p_0$, not by $p_4$,
since it requires an $a$-transition
after which both actions $b$ and $c$ should be possible.
$p_4$ does have two $a$-transitions,
but neither $p_5$ nor $p_6$ offers both $b$ and $c$.
Therefore $\varphi$ is a \emph{distinguishing formula} for $p_0$ and $p_4$,
since it points out a difference in their behavior.


\subsection{The Equivalence Spectrum}

These and many other behavioral equivalences have been collected and ordered
in the \emph{linear-time--branching-time spectrum} % chktex 8
by \textcite{glabbeek1990spectrum}.
Reasoning about all of them at once requires a more unified definition,
which can be achieved through HML-formulas.

Every notion of equivalence is characterized by a subset of HML-formulas:
if the subset includes a distinguishing formula for two processes,
that equivalence does not hold.
On the other hand, if two processes are equated,
then it is impossible to find a distinguishing formula in the respective
subset.

These subsets are characterized by giving each formula a multidimensional
cost-vector and limiting the subset to formulas up to a maximum cost value.


\section{Energy Games}\label{sec:energy_games}

\begin{definition}[Energy updates~\cite{bisping2023process}]\label{def:update}
    The set of $N$-dimensional energy updates $\mathbf{Up}_N$ contains
    $N$-tuples $(u_1, \ldots, u_N) \in \mathbf{Up}_N$ where each update $u_k, k
    \in [N]$ is
    either
    \begin{itemize}
        \item $u_k \in \{-1, 0\}$, or
        \item $u_k = \mathtt{min}_D$ where $D \subseteq [N]$ and $k \in D$. % chktex 35
    \end{itemize}

    The function
    $\mathsf{upd}_N: (\mathbf{En}_N, \mathbf{Up}_N) \rightarrow \mathbf{En}_N$
    applies an update to an energy tuple.
    The $k$-th component is given as:
    \begin{equation*}
        \mathsf{upd}_N{(e, u)}_k =
        \begin{cases}
            e_k + u_k,\quad &\text{if } u_k \in \{-1, 0\}, \\
            \min_{d \in D}{e_d},\quad &\text{if } u_k = \mathtt{min}_D. % chktex 35
        \end{cases}
    \end{equation*}
\end{definition}

\begin{definition}[Energy Games]\label{def:energy_game}
    We define an $N$-dimensional energy game as
    $(G, G_a, G_d, E, w, v_0)$, where 
    \begin{itemize}
        \item $G$ is a set of game positions.
        \item $G_a$ and $G_d$ are the sets of attacker and defender positions
            respectively.
            $G = G_a \cup G_d$ and $G_a \cap G_d = \emptyset$.
        \item $E \subseteq (G \times G)$ is the edge relation. $(G, E)$
            together form a directed game graph.
        \item $w: E \rightarrow \mathbf{Up}_N$ is a weight function, assigning an
            energy update to each edge.
        \item $v_0 \in G$ is the start position of the game.
    \end{itemize}

    The function $\mathrm{Succ}: G \rightarrow 2^G$ gives the successors in the
    graph for a position.
    For each $g \in G$, $\mathrm{Succ}(g) = \{g' \in G \mid (g, g') \in E\}$.
    Similarly, $\mathrm{Pred}(g) = \{g' \in G \mid (g', g) \in E\}$ yields a
    position's predecessors.
\end{definition}

\begin{definition}[Plays and costs]
    A \emph{play} $\rho$ on a given game is a sequence of positions:
    $\rho = g_0g_1 \ldots g_n$ where at each step
    $g_i \in G$ and $(g_i, g_{i+1}) \in E$.

    If a play cannot be further extended, that is,
    $\mathrm{Succ}(g_n) = \emptyset$,
    that play is won by the player who is not stuck:
    if $g_n \in G_a$, the defender wins, if $g_n \in G_d$, the attacker wins.
    Infinite plays are won by the defender.

    \scriptsize{TODO: costs}
\end{definition}

%TODO: Inverse update function upd^{-1}
%TODO: Energy tuples, upwards-closed sets, representation by minimal energies

\section{Spectroscopy Algorithm}
