\section{Parallelizing the Algorithm}

At the center of this contribution is a parallel GPU-implementation%
\footnote{The code can be found at \url{https://github.com/Gobbel2000/gpuequiv}}
of the energy game introduced in Section~\ref{sec:energy_games}.
Given a game graph as input, it calcu\-lates for each position the energy budgets
required for the attacker, starting at the current position, to win the game.
This algorithm was described in~\cite{bisping2023process} as part of the
spectroscopy algorithm, as well as in~\cite{brihaye2023multi} by T. Brihaye and
A. Goeminne, which more generally covers
\enquote{Multi-Weighted Reachability Games},
but presents essentially the same algorithm structure.

\begin{algorithm}[t]\label{alg:energy_game}
    \DontPrintSemicolon
    \SetKwData{Start}{start}
    \SetKwData{Visit}{visit}
    \SetKwData{Energies}{energies}
    \SetKwData{Updated}{updated}
    \SetKwData{New}{new\_energies}
    \SetKwFor{pFor}{for parallel}{do}{end}

    $\Start = \{g \in G_d \mid \mathrm{Succ}(g) = \emptyset\}$\;
    \lFor{$g \in \Start$}{$\Energies[g] = \{\mathbf{0}\}$}
    \lFor{$g \in G \setminus \Start$}{$\Energies[g] = \emptyset$}
    $\Visit = \{\mathrm{Pred}(g) \mid g \in \Start\}$\;

    \BlankLine
    \While{$\Visit \neq \emptyset$}{
        \pFor{$g \in \Visit$}{
            $\Visit = \Visit \setminus \{g\}$\;
            \For{$g' \in \mathrm{Succ}(g)$} {
                $\Updated[g'] = \{ \mathsf{upd}(e, w(g, g')) \mid e \in \Energies[g'] \}$
            }

            \BlankLine
            \eIf(\tcp*[h]{attack positions}){$g \in G_a$}{
                $\New = \mathrm{Min} \left(
                    \bigcup_{g' \in \mathrm{Succ}(g)} \uparrow \Updated[g']
                \right)$
            } (\tcp*[h]{defend positions}) {
                $\New = \mathrm{Min} \left(
                    \bigcap_{g' \in \mathrm{Succ}(g)} \uparrow \Updated[g']
                \right)$
            }

            \BlankLine
            \If{$\New \neq \Energies[g]$}{
                $\Energies[g] = \New$\;
                $\Visit = \Visit \cup \mathrm{Pred}(g)$\;
            }
        }
    }
    \Return{\Energies}

    \caption{Parallel Energy Game}
\end{algorithm}

The basic structure is as shown in Algorithm~\ref{alg:energy_game}.
In order to calculate all the winning budgets,
we start at the end of the game graph and work our way backwards.
At all defend positions with no successors the attacker immediately wins,
so we can set the energies required for the attacker to win there to the
0-valued energy tuple (lines 1--3).
In every iteration a set of positions is visited which updates its associated
energies.
The next iteration visits the predecessors of all positions, whose energies
have changed in the previous iteration, thus walking backwards in the game
graph in a breadth-first manner. Once an iteration caused no changes to the
energies, the algorithm terminates.

We achieve parallelization by visiting all positions in the visit list in
parallel, but to fully take advantage of the massively multithreaded
GPU-architecture, each position is further processed by multiple threads.

The core of the algorithm lies in lines 11--15, where the upwards-closed sets of
energies are either unioned or intersected.
Both operations demand very different approaches.
The following two sections detail how these operations have been implemented to
efficiently run on a GPU\@.


\subsection{Attack shader: Union}

\begin{figure}[t]
\begin{center}
\begin{tikzpicture}
    \node[rectangle,draw] (start_node) {\large{$g$}};
    \node (successor1) [right=of start_node,label=above:successors] {$g_1'$};

    % Energies of successors
    \node (energy1_1) [right=of successor1] {$e_{g_1',1}$};
    \node (energy1_2) [below] at (energy1_1.south) {$e_{g_1',2}$};
    \node (dots1) [below] at (energy1_2.south) {\rvdots};
    \node (energy2_1) [below] at (dots1.south) {$e_{g_2',1}$};
    \node (energy2_2) [below] at (energy2_1.south) {$e_{g_2',2}$};
    \node (dots2) [below] at (energy2_2.south) {\rvdots};

    \node (successor2) [left=of energy2_1] {$g_2'$};
    \node (dots_successors) at (successor2 |- dots2) {\rvdots};

    % Updated energies
    \node (updated1_1) [right=of energy1_1] {$e_{g_1',1}'$};
    \node (updated1_2) [right=of energy1_2] {$e_{g_1',2}'$};
    \node (udots1) at (updated1_2 |- dots1) {\rvdots};
    \node (updated2_1) [right=of energy2_1] {$e_{g_2',1}'$};
    \node (updated2_2) [right=of energy2_2] {$e_{g_2',2}'$};
    \node (udots2) at (updated2_2 |- dots2) {\rvdots};
    % Include energies of g itself
    %\node (energyg_1) [below] at (udots2.south) {$e_{g,1}$};
    %\node (energyg_2) [below] at (energyg_1.south) {$e_{g,2}$};
    %\node (udots3) [below] at (energyg_2.south) {\rvdots};

    % Minimized energies
    \node (minimal1) [right=14mm of udots1.north] {$e_1^*$};
    \node (minimal2) [below] at (minimal1.south) {$e_2^*$};
    \node (mdots) [below] at (minimal2.south) {\rvdots};

    \draw[->] (start_node.east) -- (successor1.west);
    \draw[->] (start_node.east) -- (successor2.west);
    \draw[->] (successor1) -- (energy1_1.west);
    \draw[->] (successor1) -- (energy1_2.west);
    \draw[->] (successor1) -- (energy1_2.west |- dots1);
    \draw[->] (successor2) -- (energy2_1.west);
    \draw[->] (successor2) -- (energy2_2.west);
    \draw[->] (successor2) -- (energy2_2.west |- dots2);

    \draw[->] (energy1_1) -- node (l_update) [above=2mm] {update} (updated1_1);
    \draw[->] (energy1_2) -- (updated1_2);
    \draw[->] (energy1_2.east |- dots1) -- (updated1_2.west |- udots1);
    \draw[->] (energy2_1) -- (updated2_1);
    \draw[->] (energy2_2) -- (updated2_2);
    \draw[->] (energy2_2.east |- dots2) -- (updated2_2.west |- udots2);
    % Energies from g
    %\draw[->,shorten >= 4mm] (start_node.south) |-
    %    node [near end,below] {energies of $g$}
    %    (energyg_2.west);

    % Diagonal lines suggesting the reduction to minimal energies
    \draw[thick] (updated1_1.east |- udots2.south) -- (minimal1.west |- mdots.south);
    \draw[thick] (updated1_1.north east) -- (minimal1.north west);
    \node (l_minimize) [right=7mm of l_update] {minimize};
\end{tikzpicture}
\end{center}
\caption{Data flow for processing Attack positions}%
\label{fig:attack}
\end{figure}

\subsection{Defend shader: Intersection}

\section{Data Layout}

\section{Control Flow}

\section{Limitations}
