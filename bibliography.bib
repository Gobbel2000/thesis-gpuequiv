% Encoding: UTF-8

'
@Article{Merrill2015,
  author     = {Merrill, Duane and Garland, Michael and Grimshaw, Andrew},
  date       = {2015-02},
  title      = {High-{Perfor\-mance} and {Scalable} {GPU} {Graph} {Traversal}},
  doi        = {10.1145/2717511},
  issn       = {2329-4949},
  number     = {2},
  pages      = {14:1--14:30},
  volume     = {1},
  abstract   = {Breadth-First Search (BFS) is a core primitive for graph traversal and a basis for many higher-level graph analysis algorithms. It is also representative of a class of parallel computations whose memory accesses and work distribution are both irregular and data dependent. Recent work has demonstrated the plausibility of GPU sparse graph traversal, but has tended to focus on asymptotically inefficient algorithms that perform poorly on graphs with nontrivial diameter. We present a BFS parallelization focused on fine-grained task management constructed from efficient prefix sum computations that achieves an asymptotically optimal O({\textbar}V{\textbar} + {\textbar}E{\textbar}) gd work complexity. Our implementation delivers excellent performance on diverse graphs, achieving traversal rates in excess of 3.3 billion and 8.3 billion traversed edges per second using single- and quad-GPU configurations, respectively. This level of performance is several times faster than state-of-the-art implementations on both CPU and GPU platforms.},
  comment    = {BFS on GPU. Many useful techniques, but sometimes little detail.
CSR sparse matrix format for representing graph in the GPU.},
  file       = {:../literature/gpu_graph_traversal.pdf:PDF},
  journal    = {ACM Transactions on Parallel Computing},
  keywords   = {sparse graphs, graph traversal, Breadth-first search, GPU, prefix sum, graph algorithms, parallel algorithms},
  ranking    = {rank3},
  readstatus = {read},
}

'
@InProceedings{MendezLojo2012a,
  author     = {Mendez-Lojo, Mario and Burtscher, Martin and Pingali, Keshav},
  booktitle  = {Proceedings of the 17th {ACM} {SIGPLAN} symposium on {Principles} and {Practice} of {Parallel} {Programming}},
  date       = {2012-02},
  title      = {A {GPU} implementation of inclusion-based points-to analysis},
  doi        = {10.1145/2145816.2145831},
  isbn       = {9781450311601},
  pages      = {107--116},
  publisher  = {Association for Computing Machinery},
  series     = {{PPoPP} '12},
  url        = {https://doi.org/10.1145/2145816.2145831},
  urldate    = {2023-08-11},
  abstract   = {Graphics Processing Units (GPUs) have emerged as powerful accelerators for many regular algorithms that operate on dense arrays and matrices. In contrast, we know relatively little about using GPUs to accelerate highly irregular algorithms that operate on pointer-based data structures such as graphs. For the most part, research has focused on GPU implementations of graph analysis algorithms that do not modify the structure of the graph, such as algorithms for breadth-first search and strongly-connected components. In this paper, we describe a high-performance GPU implementation of an important graph algorithm used in compilers such as gcc and LLVM: Andersen-style inclusion-based points-to analysis. This algorithm is challenging to parallelize effectively on GPUs because it makes extensive modifications to the structure of the underlying graph and performs relatively little computation. In spite of this, our program, when executed on a 14 Streaming Multiprocessor GPU, achieves an average speedup of 7x compared to a sequential CPU implementation and outperforms a parallel implementation of the same algorithm running on 16 CPU cores. Our implementation provides general insights into how to produce high-performance GPU implementations of graph algorithms, and it highlights key differences between optimizing parallel programs for multicore CPUs and for GPUs.},
  address    = {New York, NY, USA},
  comment    = {More complicated graph algorithm requiring mutating the graph a lot, which poses additional challenges on the graph data structure.},
  keywords   = {irregular programs, graph algorithms, CUDA, inclusion-based points-to analysis, GPU},
  readstatus = {skimmed},
}

'
@Article{Hijma2023,
  author   = {Hijma, Pieter and Heldens, Stijn and Sclocco, Alessio and van Werkhoven, Ben and Bal, Henri E.},
  date     = {2023-03},
  title    = {Optimization {Techniques} for {GPU} {Programming}},
  doi      = {10.1145/3570638},
  issn     = {0360-0300},
  number   = {11},
  pages    = {239:1--239:81},
  volume   = {55},
  abstract = {In the past decade, Graphics Processing Units have played an important role in the field of high-performance computing and they still advance new fields such as IoT, autonomous vehicles, and exascale computing. It is therefore important to understand how to extract performance from these processors, something that is not trivial. This survey discusses various optimization techniques found in 450 articles published in the last 14 years. We analyze the optimizations from different perspectives which shows that the various optimizations are highly interrelated, explaining the need for techniques such as auto-tuning.},
  comment  = {Very comprehensive list, good vocabulary, more than 400 references.},
  file     = {:../literature/Hijma2023 - Optimization Techniques for GPU Programming.pdf:PDF},
  journal  = {ACM Computing Surveys},
  keywords = {optimization, performance bottleneck, Survey, GPU, optimization techniques},
  ranking  = {rank5},
}

'
@Misc{Levien2021,
  author     = {Raph Levien},
  date       = {2021-11-17},
  title      = {Prefix sum on portable compute shaders},
  url        = {https://raphlinus.github.io/gpu/2021/11/17/prefix-sum-portable.html},
  urldate    = {2023-08-11},
  abstract   = {This is a followup to my previous post, prefix sum on Vulkan. Last year, I got a fancy algorithm for this problem running well on one device. This time, I will dive into the question of how to make it work well across a wide range of devices. The short answer is, it can be made to work pretty portably on Vulkan and DX12, but Metal remains out of reach, at least for now, as is WebGPU. Even on Vulkan, there are some sharp edges to watch out for.},
  comment    = {Prefix sum does not work on WebGPU because of limitations in Metal.},
  journal    = {Raph Levienâ€™s blog},
  readstatus = {read},
}

@Misc{bisping2023process,
  author        = {Benjamin Bisping},
  date          = {2023-07},
  title         = {Process Equivalence Problems as Energy Games},
  eprint        = {2303.08904},
  archiveprefix = {arXiv},
  file          = {:../literature/bisping2023process.pdf:PDF},
  primaryclass  = {cs.DS},
  readstatus    = {read},
}

@Misc{bisping2023silent,
  author        = {Bisping, Benjamin and Jansen, David N.},
  date          = {2023},
  title         = {Linear-Time-Branching-Time Spectroscopy Accounting for Silent Steps},
  eprint        = {2305.17671},
  archiveprefix = {arXiv},
  primaryclass  = {cs.LO},
}

@InProceedings{bn2019coupledsim,
  author    = {Bisping, Benjamin and Nestmann, Uwe},
  booktitle = {Proceedings of {TACAS}},
  title     = {Computing Coupled Similarity},
  year      = {2019},
  pages     = {244--261},
  publisher = {Springer},
  series    = {LNCS},
  doi       = {10.1007/978-3-030-17462-0_14},
}

@InProceedings{glabbeek1990spectrum,
  author    = {van Glabbeek, R. J.},
  booktitle = {CONCUR '90 Theories of Concurrency: Unification and Extension},
  title     = {The linear time - branching time spectrum},
  doi       = {10.1007/BFb0039066},
  editor    = {Baeten, J. C. M. and Klop, J. W.},
  isbn      = {978-3-540-46395-5},
  pages     = {278--297},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {In this paper eleven semantics in the linear time --- branching time spectrum are presented in a uniform, model-independent way. Restricted to the domain of finitely branching, concrete, sequential processes, most semantics found in the literature that can be defined uniformly in terms of action relations coincide with one of these eleven. Several testing scenarios, motivating these semantics, are presented, phrased in terms of `button pushing experiments' on generative and reactive machines. Finally nine of these semantics are applied to a simple language for finite, concrete, sequential, nondeterministic processes, and for each of them a complete axiomatization is provided.},
  address   = {Berlin, Heidelberg},
  file      = {:../literature/glabbeek1990spectrum.pdf:PDF},
  ranking   = {rank3},
  year      = {1990},
}

@Book{reactive_systems,
  author    = {Aceto, Luca and Ing\'{o}lfsd\'{o}ttir, Anna and Larsen, Kim Guldstrand and Srba, Jiri},
  date      = {2007},
  title     = {Reactive Systems: Modelling, Specification and Verification},
  isbn      = {0521875463},
  publisher = {Cambridge University Press},
  address   = {USA},
  file      = {:../../reaktive_systeme/sv-book-part1.pdf:PDF},
}

@Misc{Harris2011ParallelPS,
  author       = {Mark J. Harris},
  date         = {2007-04},
  title        = {Parallel Prefix Sum (Scan) with {CUDA}},
  organization = {NVIDIA},
  url          = {http://developer.download.nvidia.com/compute/cuda/1.1-Beta/x86_website/projects/scan/doc/scan.pdf},
  file         = {:../literature/prefix_scan.pdf:PDF},
  publisher    = {NVIDIA},
  readstatus   = {read},
}

@Article{Blom2002,
  author   = {Stefan Blom and Simona Orzan},
  title    = {A Distributed Algorithm for Strong Bisimulation Reduction of State Spaces},
  doi      = {10.1016/S1571-0661(05)80390-1},
  issn     = {1571-0661},
  note     = {PDMC 2002, Parallel and Distributed Model Checking (Satellite Workshop of CONCUR 2002)},
  number   = {4},
  pages    = {523-538},
  volume   = {68},
  abstract = {It is a known problem that state spaces can grow very big, which makes operating with them (including reducing them) difficult because of memory shortage. In the attempt to extend the size of the state spaces that can be dealt with, we designed and implemented a bisimulation reduction algorithm for distributed memory settings using message passing communication. By using message passing, the same implementation can be used on both large SMP machines and clusters of workstations. The algorithm performs reduction of large labeled transition systems modulo strong bisimulation. We justify its correctness and termination. We provide an evaluation of the worst-case time and message complexity and some performance data from a prototype implementation. Both theory and practice show that the algorithm scales up with the number of workers.},
  journal  = {Electronic Notes in Theoretical Computer Science},
  year     = {2002},
}

@Misc{brihaye2023multi,
  author        = {Brihaye, Thomas and Goeminne, Aline},
  date          = {2023-08},
  title         = {Multi-Weighted Reachability Games},
  eprint        = {2308.09625},
  archiveprefix = {arXiv},
  file          = {:../literature/brihaye2023multi.pdf:PDF},
  primaryclass  = {cs.GT},
}

@InProceedings{Delzanno2000,
  author    = {Delzanno, Giorgio and Raskin, Jean-Fran{\c{c}}cois},
  booktitle = {Tools and Algorithms for the Construction and Analysis of Systems},
  date      = {2000-03},
  title     = {Symbolic Representation of Upward-Closed Sets},
  editor    = {Graf, Susanne and Schwartzbach, Michael},
  isbn      = {978-3-540-46419-8},
  pages     = {426--441},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {The control state reachability problem is decidable for well-structured infinite-state systems like unbounded Petri Nets, Vector Addition Systems, Lossy Petri Nets, and Broadcast Protocols. An abstract algorithm that solves the problem is given in [A{\v{C}}JT96,FS99]. The algorithm computes the closure of the predecessor operator w.r.t. a given upward-closed set of target states. When applied to this class of verification problems, traditional (infinite-state) symbolic model checkers suffer from the state explosion problem even for very small examples. We provide BDD-like data structures to represent in a compact way collections of upwards closed sets over numerical domains. This way, we turn the abstract algorithm of [A{\v{C}}JT96,FS99] into a practical method. Preliminary experimental results indicate the potential usefulness of our method.},
  address   = {Berlin, Heidelberg},
}

@InProceedings{Busato2018,
  author    = {Busato, Federico and Green, Oded and Bombieri, Nicola and Bader, David A.},
  booktitle = {2018 IEEE High Performance extreme Computing Conference (HPEC)},
  date      = {2018-11},
  title     = {Hornet: An Efficient Data Structure for Dynamic Sparse Graphs and Matrices on GPUs},
  doi       = {10.1109/HPEC.2018.8547541},
  pages     = {1-7},
  keywords  = {Dynamic Graph Structures;GPU Computing;Graph Analytics},
}

@Misc{vlts,
  author       = {Garavel, Hubert},
  date         = {2018},
  title        = {{VLTS} Benchmark Suite},
  doi          = {10.18709/perscido.2017.11.ds100},
  howpublished = {Jointly created by CWI/SEN2 and INRIA/VASY as a CADP resource.},
}

@Book{Patterson2016,
  author    = {Patterson, David and Hennessy, John Leroy},
  date      = {2016-05},
  title     = {Rechnerorganisation und Rechnerentwurf},
  edition   = {5},
  isbn      = {978-3-11-044605-0},
  language  = {german},
  publisher = {Walter de Gruyter},
  series    = {de Gruyter Studium},
  langid    = {ngerman},
}

@Manual{wgsl_spec,
  date         = {2024-03-31},
  editor       = {Baker, Alan and Derin, Mehmet Oguz and Neto, David and Maxfield, Myles C. and Sinclair, Dan},
  title        = {{WebGPU} Shading Language},
  organization = {W3C},
  pubstate     = {Working Draft},
  url          = {https://www.w3.org/TR/2024/WD-WGSL-20240331},
}

@Article{Bisping2022,
  author       = {Bisping, Benjamin and Jansen, David N. and Nestmann, Uwe},
  date         = {2022-08},
  journaltitle = {Logical Methods in Computer Science},
  title        = {Deciding {All} {Behavioral} {Equivalences} at {Once}: {A} {Game} for {Linear}-{Time}--{Branching}-{Time} {Spectroscopy}},
  doi          = {10.46298/lmcs-18(3:19)2022},
  issn         = {1860-5974},
  volume       = {Volume 18, Issue 3},
  abstract     = {We introduce a generalization of the bisimulation game that finds distinguishing Hennessy-Milner logic formulas from every finitary, subformula-closed language in van Glabbeek's linear-time--branching-time spectrum between two finite-state processes. We identify the relevant dimensions that measure expressive power to yield formulas belonging to the coarsest distinguishing behavioral preorders and equivalences; the compared processes are equivalent in each coarser behavioral equivalence from the spectrum. We prove that the induced algorithm can determine the best fit of (in)equivalences for a pair of processes.},
  publisher    = {Episciences.org},
  shorttitle   = {Deciding {All} {Behavioral} {Equivalences} at {Once}},
}

@Article{Martens2023,
  author    = {Jan Martens and Groote, {Jan Friso} and Haak, {Lars B.van den} and Pieter Hijma and Anton Wijs},
  date      = {2023-04},
  title     = {Linear parallel algorithms to compute strong and branching bisimilarity},
  doi       = {10.1007/s10270-022-01060-7},
  issn      = {1619-1366},
  number    = {2},
  pages     = {521--545},
  volume    = {22},
  abstract  = {We present the first parallel algorithms that decide strong and branching bisimilarity in linear time. More precisely, if a transition system has n states, m transitions and | Act| action labels, we introduce an algorithm that decides strong bisimilarity in O(n+ | Act|) time on max (n, m) processors and an algorithm that decides branching bisimilarity in O(n+ | Act|) time using up to max (n2, m, | Act| n) processors.},
  journal   = {Software and Systems Modeling},
  keywords  = {Branching bisimulation, Parallel algorithms, PRAM, RCPP, Strong bisimulation},
  publisher = {Springer},
}

@InProceedings{Wijs2023,
  author    = {Anton Wijs and Muhammad Osama},
  booktitle = {Model Checking Software - 29th International Symposium, SPIN 2023, Proceedings},
  date      = {2023-05},
  title     = {GPUexplore 3.0: GPU Accelerated State Space Exploration for Concurrent Systems with Data.},
  doi       = {10.1007/978-3-031-32157-3_11},
  editor    = {Georgiana Caltais and Christian Schilling},
  pages     = {188--197},
  series    = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  abstract  = {GPUexplore 3.0 is an explicit state space exploration tool that runs entirely on a graphics processing unit (GPU), and supports models of concurrent systems with data variables. We discuss its workflow and modelling language, present several design decisions regarding work distribution and retrieval, and experimentally evaluate the impact of those decisions. Our tool achieves acceleration up to 115 Ã— and 28 Ã— compared to single- and four-core LTSmin, respectively. It currently checks for deadlocks, with verification of temporal logic formulae planned for the near future.},
  keywords  = {Explicit state space exploration, GPU, finite-state machines},
}

@Comment{jabref-meta: databaseType:biblatex;}
